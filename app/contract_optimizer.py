"""Module defining the methods to find the optimal path of contracts."""
from typing import List

contracts = []


def find_optimal_path_and_income(
    unsorted_contracts: List[dict],
) -> tuple[int, List[str]]:
    """Finds the optimal path and income among a list of unsorted contracts.

    Args:
        unsorted_contracts: List of dictionaries containing the contract
        information.

    Returns:
        int: the income which could be generated by following the most optimal path
        List[str]: the list of contract names which make up the most optimal path

    """
    for contract in unsorted_contracts:
        contract["end"] = contract["start"] + contract["duration"]
    global contracts
    contracts = sorted(unsorted_contracts, key=lambda d: d["start"])
    income, path = find_optimum(0, 0)
    return income, path


def get_next_eligible_contract_id(index: int = 0, start: int = 0) -> int:
    """Finds the next contract in the global variable list of contracts.

    The next contract starts at the given `start` hour or right after.

    Args:
        start: All contracts in `contracts` which start on or after `start`
        will be returned.
        index: Only contracts after the id `index` are scanned, for efficiency.

    Returns:
        int: index of the next contract which starts on or after the `start`
        argument. The returned index is capped at the length of the global `contracts`
        variable.
    """
    while index < len(contracts):
        if contracts[index].get("start") >= start:
            return index
        index += 1

    return len(contracts)


def find_optimum(start: int = 0, index: int = 0) -> tuple[int, List[str]]:
    """Finds the optimal combination of contracts in the global variable
    `contracts`.

    Starting from the timestamp `start` and index `index`, this method will
    calculate all feasible combinations of contracts and their total contract
    price in a recursive manner and will return the total price and path
    of the most price-optimal combination. The contracts in the global
    variable `contracts` are assumed to be sorted in ascending order
    according to the `start` attribute.

    Args:
        start: integer indicating an hour, beyond which the optimal search
        will start.
        index: index of the list of contracts. All contracts beyond this
        index will be searched.

    Returns:
        int: The total price of the most optimal contract combination.
        List[str]: List of contract names, which make up the  optimal
        combination of contracts.

    """
    next_eligible_contract_id = get_next_eligible_contract_id(index, start)
    if next_eligible_contract_id == len(contracts):
        return 0, []
    next_eligible_contract = contracts[next_eligible_contract_id]

    # First case: the `next_eligible_contract` is part of the solution,
    # so we move the start value to the end of the `next_eligible_contract`
    # and move the index forward. Effectively calculating the optimum
    # of the remaining contracts after the `next_eligible_contract` has ended.
    income_1, path_1 = find_optimum(next_eligible_contract.get("end"), index + 1)
    # Second case: we discard the `next_eligible_contract` and keep the
    # start value as is. Effectively calculating the optimum of the
    # remaining contracts whilst disregarding the `next_eligible_contract`.
    income_2, path_2 = find_optimum(start, index + 1)

    income_1 = next_eligible_contract.get("price") + income_1
    if income_1 >= income_2:
        path_1 = [next_eligible_contract.get("name")] + path_1
        return income_1, path_1

    return income_2, path_2
