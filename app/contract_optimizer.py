"""Module defining the methods to find the optimal path of contracts."""
from typing import List

contracts = []


def find_optimal_path_and_income(
    unsorted_contracts: List[dict],
) -> tuple[int, List[str]]:
    """Finds the optimal path and income among a list of unsorted contracts.

    Args:
        unsorted_contracts: List of dictionaries containing the contract
        information.

    Returns:
        int: the income which could be generated by following the most optimal path
        List[str]: the list of contract names which make up the most optimal path

    """
    for contract in unsorted_contracts:
        contract["end"] = contract["start"] + contract["duration"]
    global contracts
    contracts = sorted(unsorted_contracts, key=lambda d: d["start"])
    income, path = find_optimum(0, 0)
    return income, path


def get_eligible_contracts(index: int = 0, start: int = 0) -> List[dict]:
    """Finds the next contract in the global variable list of contracts.

    The next contract starts at the given `start` hour or right after
    and returns all contracts which start on or after this next contract.

    Args:
        start: All contracts in `contracts` which start on or after `start`
        will be returned.
        index: Only contracts after the id `index` are scanned, for efficiency.

    Returns:
        List[dict]: List of contracts which start on or after the given
        `start` hour.
    """
    remaining_contracts = contracts[index:]
    i = 0
    while i < len(remaining_contracts):
        if remaining_contracts[i].get("start") >= start:
            return remaining_contracts[i:]
        i += 1


def find_optimum(start: int = 0, index: int = 0) -> tuple[int, List[str]]:
    """Finds the optimal combination of contracts in the global variable
    `contracts`.

    Starting from the timestamp `start` and index `index`, this method will
    calculate all feasible combinations of contracts and their total contract
    price in a recursive manner and will return the total price and path
    of the most price-optimal combination. The contracts in the global
    variable `contracts` are assumed to be sorted in ascending order
    according to the `start` attribute.

    Args:
        start: integer indicating an hour, beyond which the optimal search
        will start.
        index: index of the list of contracts. All contracts beyond this
        index will be searched.

    Returns:
        int: The total price of the most optimal contract combination.
        List[str]: List of contract names, which make up the  optimal
        combination of contracts.

    """
    eligible_contracts = get_eligible_contracts(index, start)
    if not eligible_contracts:
        return 0, []
    next_eligible_contract = eligible_contracts[0]

    # First case: the `next_eligible_contract` is part of the solution,
    # so we move the start value to the end of the `next_eligible_contract`
    # and move the index forward. Effectively calculating the optimum
    # of the remaining contracts after the `next_eligible_contract` has ended.
    income_1, path_1 = find_optimum(next_eligible_contract.get("end"), index + 1)
    # Second case: we discard the `next_eligible_contract` and keep the
    # start value as is. Effectively calculating the optimum of the
    # remaining contracts whilst disregarding the `next_eligible_contract`.
    income_2, path_2 = find_optimum(start, index + 1)

    total_price_1 = next_eligible_contract.get("price") + income_1
    if total_price_1 >= income_2:
        path = [next_eligible_contract.get("name")] + path_1
        return total_price_1, path

    return income_2, path_2
