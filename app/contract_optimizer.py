"""Module defining the methods to find the optimal path of contracts."""
from typing import List
from app.models import Contract

contracts = []
solution_cache = {}


def find_optimal_path_and_income(
    unsorted_contracts: List[dict],
) -> tuple[int, List[str]]:
    """Finds the optimal path and income among a list of unsorted contracts.

    Args:
        unsorted_contracts: List of dictionaries containing the contract
        information.

    Returns:
        int: the income which could be generated by following the most optimal path
        List[str]: the list of contract names which make up the most optimal path

    """
    for contract in unsorted_contracts:
        contract["end"] = contract["start"] + contract["duration"]
    global contracts
    global solution_cache
    contracts = sorted(unsorted_contracts, key=lambda d: d["start"])
    income, path = find_optimum(0, 0)
    return income, path


def get_next_eligible_contract_id(index: int = 0, start: int = 0) -> int:
    """Finds the next contract in the global variable list of contracts.

    The next contract starts at the given `start` hour or right after.

    Args:
        start: All contracts in `contracts` which start on or after `start`
        will be returned.
        index: Only contracts after the id `index` are scanned, for efficiency.

    Returns:
        int: index of the next contract which starts on or after the `start`
        argument. The returned index is capped at the length of the global `contracts`
        variable.
    """
    while index < len(contracts):
        if contracts[index].get("start") >= start:
            return index
        index += 1

    return len(contracts)


def get_best_contract(index) -> Contract:
    """Returns the contract which is better (= shorter or equal in length, but
    more lucrative) than the contract given by index. All contracts which

    - Start at the same time or after the contract given by index,
    - End at the same time or before the contract given by index

    are searched.

    Args:
        index: Contract index.

    Returns:
        Contract: The most lucrative contract which starts after and ends before
        the contract given by the contract index.
    """
    best_contract = contracts[index]
    end = best_contract.get("end")
    while index < len(contracts):
        contract = contracts[index]
        if contract.get("end") <= end and contract.get("price") > best_contract.get(
            "price"
        ):
            best_contract = contract
        index += 1

    return best_contract


def find_optimum(start: int = 0, index: int = 0) -> tuple[int, List[str]]:
    """Finds the optimal combination of contracts in the global variable
    `contracts`.

    Starting from the timestamp `start` and index `index`, this method will
    calculate all feasible combinations of contracts and their total contract
    price in a recursive manner and will return the total price and path
    of the most price-optimal combination. The contracts in the global
    variable `contracts` are assumed to be sorted in ascending order
    according to the `start` attribute.

    Args:
        start: integer indicating an hour, beyond which the optimal search
        will start.
        index: index of the list of contracts. All contracts beyond this
        index will be searched.

    Returns:
        int: The total price of the most optimal contract combination.
        List[str]: List of contract names, which make up the  optimal
        combination of contracts.
    """
    if start in solution_cache:
        income, path = solution_cache.get(start)
        return income, path

    next_eligible_contract_id = get_next_eligible_contract_id(index, start)
    if next_eligible_contract_id == len(contracts):
        return 0, []
    next_eligible_contract = contracts[next_eligible_contract_id]

    if next_eligible_contract.get("end") in solution_cache:
        income, path = solution_cache.get(next_eligible_contract.get("end"))
        best_contract = get_best_contract(next_eligible_contract_id)
        return income + best_contract.get("price"), [best_contract.get("name")] + path

    else:
        income_1, path_1 = find_optimum(next_eligible_contract.get("end"), index + 1)
        income_2, path_2 = find_optimum(start, index + 1)

        income_1 = next_eligible_contract.get("price") + income_1
        if income_1 >= income_2:
            path = [next_eligible_contract.get("name")] + path_1
            solution_cache.update({start: (income_1, path)})
            return income_1, path
        else:
            solution_cache.update({start: (income_2, path_2)})
            return income_2, path_2
